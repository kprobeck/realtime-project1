<!DOCTYPE html>
<html lang="en">
<head>
  
    <style>
        canvas {
            border: 2px solid black;
        }
      
      #promptHeader {
        color: red;
      }
      
      #currentUserListItem {
        color: red;
      }
    </style>
  
    <script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script type="text/babel" >
        "use strict";
        let socket;
        let canvas;
        let ctx;
        let sendBufferCanvas;
        let sendBufferCtx;
        
        let colorSelect;
        let mouseX;
        let mouseY;
        let prevX;
        let prevY;
        let mousedown;
        
        let brushSizeSelect;
        let brushSize;

        let brushSelect;
        let brushType;

        let clearButton;

        let joined;
        let joinButton;

        let users = {};
        let userList;

        let gameStarted;
        let isTurn;

        let userTimeStamp;
        let currentUser;

        let guessButton;
        
        // init function
        const init = () => {
          
          canvas = document.querySelector("#mainCanvas");
		  ctx = canvas.getContext('2d');
          colorSelect = document.querySelector("#colorSelect");
          brushSizeSelect = document.querySelector("#sizeSelect");
          brushSelect = document.querySelector("#brushSelect");
          clearButton = document.querySelector("#clearButton");
          joinButton = document.querySelector("#joinButton");
          guessButton = document.querySelector("#guessButton");
          userList = document.querySelector("#userList");
          
          ctx.fillStyle = 'black';
          ctx.strokeStyle = 'black';
          
          joined = false;
          gameStarted = false;
          userTimeStamp = 1;
          currentUser = 0;
          
          // set initial values for brushSelect and brushSize
          brushType = 'square';
          brushSize = 3;
          
          // add a listener on the canvas to grab the mouse location every time it moves
          canvas.addEventListener('mousemove', (e) => {
            getMousePos(canvas, e);
            
            if(mousedown && (currentUser == userTimeStamp)) {
              switch(brushType) {
              case 'square':
                ctx.fillRect(mouseX, mouseY, brushSize, brushSize);
                break;
              case 'circle':
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, brushSize, 0, 2 * Math.PI);
                ctx.closePath();
                ctx.fill();
                break;
              case 'line':
                ctx.lineWidth = brushSize;
                ctx.beginPath();
                ctx.moveTo(prevX, prevY);
                ctx.lineTo(mouseX, mouseY);
                ctx.closePath();
                ctx.stroke();
              default:
                ctx.fillRect(mouseX, mouseY, brushSize, brushSize);;
            }
              drawToBufferCtx();
            }
          }, false);
          
          // add listeners on the window to see if the mouse is being pressed down
          window.addEventListener('mousedown', () => {
            mousedown = true;
          });
          
          window.addEventListener('mouseup', () => {
            mousedown = false;
          });
          
          // events for interacting with page
          colorSelect.onchange = (e) => {
            ctx.fillStyle = e.target.value;
            sendBufferCtx.fillStyle = e.target.value;
            
            ctx.strokeStyle = e.target.value;
            sendBufferCtx.strokeStyle = e.target.value;
          };
          
          sizeSelect.onchange = (e) => {
            brushSize = e.target.value;
          };
          
          brushSelect.onchange = (e) => {
            brushType = e.target.value;
          };
          
          clearButton.onclick = (e) => {
            if(currentUser == userTimeStamp) {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              sendBufferCtx.clearRect(0, 0, canvas.width, canvas.height);
              socket.emit('clearCanvas');
            }
          };
          
          // hook up join button to have the user join the server
          joinButton.onclick = (e) => {
            if(!joined) {
              let name = document.querySelector("#usernameInput").value;
              // let room = document.querySelector("#roomInput").value;
              let data = {
                name: name,
                timeStamp: new Date().getTime(),
                // roomCode: room,
              };
              socket.emit('join', data);
              joined = true;
              document.querySelector("#usernameInput").disabled = 'disabled';
              userTimeStamp = data.timeStamp;
            }
          };
          
          // hook up guess button to submit and potentially receive points
          guessButton.onclick = (e) => {
            // only allowed to guess if it is not your turn
            if(currentUser != userTimeStamp) {
              let guess = document.querySelector("#guessInput").value;
              let data = {
                guess: guess,
                userTimeStamp: userTimeStamp,
              };
              socket.emit('guessSent', data);
              
              document.querySelector("#guessInput").value = "";
            }
          };
          
          // hook up sockets, then get first prompt
          socket = io.connect();
          
          setupSocket();
          
          /*setInterval( () => {
            socket.emit('getPrompt');
          }, 20000);*/
        };
        
        window.onload = init;

        // function to give what is being drawn to the current canvas to also be sent to the buffer canvas
        const drawToBufferCtx = () => {
          
            switch(brushType) {
              case 'square':
                sendBufferCtx.fillRect(mouseX, mouseY, brushSize, brushSize);
                break;
              case 'circle':
                sendBufferCtx.beginPath();
                sendBufferCtx.arc(mouseX, mouseY, brushSize, 0, 2 * Math.PI);
                sendBufferCtx.closePath();
                sendBufferCtx.fill();
                break;
              case 'line':
                sendBufferCtx.lineWidth = brushSize;
                sendBufferCtx.beginPath();
                sendBufferCtx.moveTo(prevX, prevY);
                sendBufferCtx.lineTo(mouseX, mouseY);
                sendBufferCtx.closePath();
                sendBufferCtx.stroke();
              default:
                sendBufferCtx.fillRect(mouseX, mouseY, brushSize, brushSize);
            }
          
            const imgDat = sendBufferCanvas.toDataURL(); // pixel data from canvas
            
            const data = {
              x: 0,
              y: 0,
              height: canvas.height,
              width: canvas.width,
              imgData: imgDat,
            };
          
            socket.emit('draw', data);
          };

        // function to get mouse location, but first set previous locations just in case we need to draw a line
        const getMousePos = (canvas, e) => {
          prevX = mouseX;
          prevY = mouseY;
          var rect = canvas.getBoundingClientRect();
          mouseX = e.clientX - rect.left;
          mouseY = e.clientY - rect.top;
        };

        // socket setup function
        const setupSocket = () => {
          sendBufferCanvas = document.createElement("canvas");
          sendBufferCanvas.height = canvas.height;
          sendBufferCanvas.width = canvas.width;
          sendBufferCtx = sendBufferCanvas.getContext("2d");
          
          
          socket.on('drawToCanvas', (data) => {
            let image = new Image();
            
            image.onload = () => {
              ctx.save();
              ctx.globalCompositeOperation = "source-over"; // default
              ctx.drawImage(image, data.x, data.y, data.width, data.height);
              ctx.restore();
            };
            
            image.src = data.imgData;
          });
          
          socket.on('newPrompt', (data) => {
            document.querySelector("#promptHeader").innerHTML = `Your prompt: ${data.prompt}`;
          });
          
          socket.on('guessThePrompt', () => {
            document.querySelector("#promptHeader").innerHTML = `Try guessing what ${users[currentUser].name} is drawing!`;
          });
          
          socket.on('eraseCanvas', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            sendBufferCtx.clearRect(0, 0, canvas.width, canvas.height);
          });
          
          socket.on('startGame', (data) => {
            gameStarted = true;
            currentUser = data;
            if(currentUser == userTimeStamp) {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              sendBufferCtx.clearRect(0, 0, canvas.width, canvas.height);
              socket.emit('clearCanvas');
              socket.emit('getPrompt');
              document.querySelector("#guessInput").value = 'YOUR TURN TO DRAW!';
              document.querySelector("#guessInput").disabled = 'disabled';
            }
          });
          
          socket.on('correctGuess', (data) => {
            document.querySelector("#guessInput").disabled = 'disabled';
          });
          
          // update user info
          socket.on('userData', (data) => {
            users = data;
            
            let innerHTML = "";
            
            // update user list
            let keysOfUsers = Object.keys(users);
            for(let i = 0; i < keysOfUsers.length; i++) {
              const username = users[keysOfUsers[i]].name;
              const score = users[keysOfUsers[i]].points;
              if(currentUser == keysOfUsers[i]) {
                innerHTML += `<li id="currentUserListItem">${username}: ${score} points</li>`;
              } else {
                innerHTML += `<li>${username}: ${score} points</li>`;
              }
            }
            
            userList.innerHTML = innerHTML;
            
          });
          
        };
    
    </script>
</head>
<body>
  <h1>Draw Together!</h1>
  Enter a Name: <input type="text" id="usernameInput">
  <!-- Enter a Room Code:<input type="text" id="roomInput"> -->
  <button id="joinButton">Join</button><br>
  <canvas id="mainCanvas" width="700" height="500">
	Cannot create canvas element...
	</canvas>
  <h2>Current Users:</h2>
  <ul id="userList">
  </ul>
  <h2 id="promptHeader">Waiting for 3 Players to Join!</h2>
  Guess the Prompt: <input type="text" id="guessInput">
  <button id="guessButton">Submit</button><br>
  <h3>Color:</h3>
  <select id="colorSelect">
    <option value="black">Black</option>
    <option value="red">Red</option>
    <option value="orange">Orange</option>
    <option value="yellow">Yellow</option>
    <option value="green">Green</option>
    <option value="blue">Blue</option>
    <option value="#4B0082">Indigo</option>
    <option value="purple">Violet</option>
  </select>
  
  <h3>Brush Size:</h3>
  <select id="sizeSelect">
    <option value="3">3</option>
    <option value="10">10</option>
    <option value="10">25</option>
  </select>
  
  <h3>Brush Style:</h3>
  <select id="brushSelect">
    <option value='square'>Square</option>
    <option value='circle'>Circle</option>
    <option value='line'>Line</option>
  </select>
  
  <button id="clearButton">Clear</button>
</body>
</html>